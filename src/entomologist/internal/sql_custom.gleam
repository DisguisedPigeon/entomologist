//// Custom queries based on the types generated by squirrel.
////
//// This is to better support nullables, since there's no detection implemented.

// Import generated types for the original query
import entomologist/internal/sql.{
  type Level, type SearchLogRow, Alert, Critical, Debug, Emergency, Error, Info,
  Notice, SearchLogRow, Warning,
}
import gleam/dynamic/decode
import gleam/option.{type Option}
import pog

pub fn search_log(
  db: pog.Connection,
  arg_1: Option(Level),
  arg_2: Option(String),
  arg_3: Option(String),
  arg_4: Option(Int),
  arg_5: Option(String),
  arg_6: Option(Int),
  arg_7: Option(Bool),
  arg_8: Option(Int),
  arg_9: Option(Bool),
) -> Result(pog.Returned(SearchLogRow), pog.QueryError) {
  let decoder = {
    use id <- decode.field(0, decode.int)
    use message <- decode.field(1, decode.string)
    use level <- decode.field(2, level_decoder())
    use module <- decode.field(3, decode.string)
    use function <- decode.field(4, decode.string)
    use arity <- decode.field(5, decode.int)
    use file <- decode.field(6, decode.string)
    use line <- decode.field(7, decode.int)
    use resolved <- decode.field(8, decode.bool)
    use last_occurrence <- decode.field(9, decode.int)
    use snoozed <- decode.field(10, decode.bool)
    decode.success(SearchLogRow(
      id:,
      message:,
      level:,
      module:,
      function:,
      arity:,
      file:,
      line:,
      resolved:,
      last_occurrence:,
      snoozed:,
    ))
  }

  "select * from logs
where ($1::level is null or level = $1)
  and ($2::text is null or module = $2)
  and ($3::text is null or function = $3)
  and ($4::int is null or arity = $4)
  and ($5::text is null or file = $5)
  and ($6::int is null or line = $6)
  and ($7::bool is null or resolved = $7)
  and ($8::bigint is null or last_occurrence = $8)
  and ($9::bool is null or snoozed = $9)
"
  |> pog.query
  |> pog.parameter(pog.nullable(level_encoder, arg_1))
  |> pog.parameter(pog.nullable(pog.text, arg_2))
  |> pog.parameter(pog.nullable(pog.text, arg_3))
  |> pog.parameter(pog.nullable(pog.int, arg_4))
  |> pog.parameter(pog.nullable(pog.text, arg_5))
  |> pog.parameter(pog.nullable(pog.int, arg_6))
  |> pog.parameter(pog.nullable(pog.bool, arg_7))
  |> pog.parameter(pog.nullable(pog.int, arg_8))
  |> pog.parameter(pog.nullable(pog.bool, arg_9))
  |> pog.returning(decoder)
  |> pog.execute(db)
}

fn level_decoder() -> decode.Decoder(Level) {
  use level <- decode.then(decode.string)
  case level {
    "debug" -> decode.success(Debug)
    "info" -> decode.success(Info)
    "notice" -> decode.success(Notice)
    "warning" -> decode.success(Warning)
    "error" -> decode.success(Error)
    "critical" -> decode.success(Critical)
    "alert" -> decode.success(Alert)
    "emergency" -> decode.success(Emergency)
    _ -> decode.failure(Debug, "Level")
  }
}

fn level_encoder(level) -> pog.Value {
  case level {
    Debug -> "debug"
    Info -> "info"
    Notice -> "notice"
    Warning -> "warning"
    Error -> "error"
    Critical -> "critical"
    Alert -> "alert"
    Emergency -> "emergency"
  }
  |> pog.text
}
