//// Custom queries based on the types generated by squirrel.
////
//// This is to better support nullables, since there's no detection implemented.

// Import generated types for the original query
import entomologist/internal/sql.{
  type Level, type SearchLogRow, Alert, Critical, Debug, Emergency, Error, Info,
  Notice, SearchLogRow, Warning,
}
import gleam/dynamic/decode
import gleam/option.{type Option}
import pog

pub fn search_log(
  db: pog.Connection,
  arg_1: Option(String),
  arg_2: Option(Level),
  arg_3: Option(String),
  arg_4: Option(String),
  arg_5: Option(Int),
  arg_6: Option(String),
  arg_7: Option(Int),
  arg_8: Option(Bool),
  arg_9: Option(Int),
  arg_10: Option(Bool),
) -> Result(pog.Returned(SearchLogRow), pog.QueryError) {
  let decoder = {
    use id <- decode.field(0, decode.int)
    use message <- decode.field(1, decode.string)
    use level <- decode.field(2, level_decoder())
    use last_occurrence <- decode.field(9, decode.int)
    decode.success(SearchLogRow(id:, message:, level:, last_occurrence:))
  }

  "-- Since nullability is not detected by squirrel, I'll have to give up type-safety and implement this query in gleam on a custom function in custom_sql.gleam.
select * from logs
where ($1::text is null or LOWER(message) LIKE $1)
  and ($3::text is null or LOWER(module) LIKE $3)
  and ($2::level is null or level = $2)
  and ($4::text is null or LOWER(function) LIKE $4)
  and ($5::int is null or arity = $5)
  and ($6::text is null or LOWER(file) LIKE $6)
  and ($7::int is null or line = $7)
  and ($8::bool is null or resolved = $8)
  and ($9::bigint is null or last_occurrence = $9)
  and ($10::bool is null or muted = $10)
"
  |> pog.query
  |> pog.parameter(pog.nullable(pog.text, arg_1))
  |> pog.parameter(pog.nullable(level_encoder, arg_2))
  |> pog.parameter(pog.nullable(pog.text, arg_3))
  |> pog.parameter(pog.nullable(pog.text, arg_4))
  |> pog.parameter(pog.nullable(pog.int, arg_5))
  |> pog.parameter(pog.nullable(pog.text, arg_6))
  |> pog.parameter(pog.nullable(pog.int, arg_7))
  |> pog.parameter(pog.nullable(pog.bool, arg_8))
  |> pog.parameter(pog.nullable(pog.int, arg_9))
  |> pog.parameter(pog.nullable(pog.bool, arg_10))
  |> pog.returning(decoder)
  |> pog.execute(db)
}

fn level_decoder() -> decode.Decoder(Level) {
  use level <- decode.then(decode.string)
  case level {
    "debug" -> decode.success(Debug)
    "info" -> decode.success(Info)
    "notice" -> decode.success(Notice)
    "warning" -> decode.success(Warning)
    "error" -> decode.success(Error)
    "critical" -> decode.success(Critical)
    "alert" -> decode.success(Alert)
    "emergency" -> decode.success(Emergency)
    _ -> decode.failure(Debug, "Level")
  }
}

fn level_encoder(level) -> pog.Value {
  case level {
    Debug -> "debug"
    Info -> "info"
    Notice -> "notice"
    Warning -> "warning"
    Error -> "error"
    Critical -> "critical"
    Alert -> "alert"
    Emergency -> "emergency"
  }
  |> pog.text
}
